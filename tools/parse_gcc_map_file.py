#!/usr/bin/env python
'''
parse_gcc_map_file.py

Provides a summary for FLASH and RAM usage, based on the .map file
generated by the linker.

This file is specific for the map format generated by GCC.
Hint: to generate the map file add the -Map=MAPFILENAME to the linker flags

Author:         Werner Lane
E-mail:         laneboysrc@gmail.com
'''

from __future__ import print_function

import sys
import argparse
import re


def parse_section_dict(dictionary):
    ''' Convert numbers in a section dictionary from strings to integers,
        and set the 'area' to either 'RAM' or 'FLASH' if 'writeable' is 'w'
    '''

    for key in ('start_address', 'size'):
        dictionary[key] = int(dictionary[key], 16)

    if 'writeable' in dictionary:
        if dictionary['writeable'] == 'w':
            dictionary['area'] = "RAM"
        else:
            dictionary['area'] = 'FLASH'
        del dictionary['writeable']

    return dictionary


def parse_memory_sections(map_data):
    ''' Obtain the memory sections (FLASH, RAM ...) '''

    re_flags = re.MULTILINE + re.DOTALL + re.IGNORECASE + re.VERBOSE
    memory_configuration_re = r'''
        .*
        Memory\sConfiguration
        .*
        Attributes
        (.*)
        Linker\sscript\sand\smemory\smap
        .*'''

    entry_re = r'''
        (?P<section_name>\S*)
        \s+
        (?P<start_address>0x\S*)
        \s+
        (?P<size>0x\S*)
        \s+
        xr(?P<writeable>.?)
        '''

    try:
        memory_configuration = re.match(memory_configuration_re, map_data,
            flags=re_flags).group(1)

    except AttributeError:
        print("ERROR: map file does not contain memory configuration")
        sys.exit(1)

    memory_sections = []
    for match in re.finditer(entry_re, memory_configuration, flags=re_flags):
        memory_sections.append(parse_section_dict(match.groupdict()))

    return memory_sections


def parse_memory_map(map_data):
    ''' Obtain the memory map part of the map file '''

    re_flags = re.MULTILINE + re.DOTALL + re.IGNORECASE + re.VERBOSE
    memory_map_re = r'''
        .*
        Linker\sscript\sand\smemory\smap
        (.*)
        (?:Cross\sReference\sTable)?    # May or may not be present
        .*
        '''

    try:
        memory_map = re.match(memory_map_re, map_data, flags=re_flags).group(1)
    except AttributeError:
        print("ERROR: Unable to find memory map in the map file")
        sys.exit(1)

    return memory_map


def get_category(module_name):
    ''' Categorize module names for the summary this tool outputs '''

    if re.match(r'/lib.+\.a$', module_name):
        return 'System libraries'

    if module_name == 'crt0.o':
        return 'Runtime'

    if re.match(r'.+\.o$', module_name):
        return module_name

    return '(others)'


def process_sections(memory_map, memory_sections):
    ''' Parse each section that does not have an intializer '''
    re_flags = re.VERBOSE + re.MULTILINE
    section_re = r'''
        ^
        [ ]
        [\.\*]?(?P<name>\S+?)\*?
        \s+
        (?P<start_address>0x\S+)
        \s+
        (?P<size>0x\S+)
        \s+
        (?P<module_name>.*)
        $
        '''

    sections_to_ignore = ("ARM.attributes", "comment")
    totals = dict(RAM=0, FLASH=0)

    for match in re.finditer(section_re, memory_map, flags=re_flags):

        section = parse_section_dict(match.groupdict())

        if section['size'] == 0 or section['start_address'] == 0:
            continue

        if section['name'] in sections_to_ignore:
            continue

        if section['name'].startswith('debug_'):
            continue

        for memory_section in memory_sections:
            start = memory_section['start_address']
            size = memory_section['size']
            end = start + size
            if start <= section['start_address'] <= end:
                section['area'] = memory_section['area']
                totals[section['area']] += section['size']

        category = get_category(section['module_name'])
        print(section)

    print(totals)


def map_file_parser(args):
    ''' Parse the map file and print FLASH and RAM summary information '''
    map_data = args.mapfile[0].read()

    memory_sections = parse_memory_sections(map_data)

    memory_map = parse_memory_map(map_data)

    process_sections(memory_map, memory_sections)


def parse_commandline():
    ''' Simulate a receiver with built-in preprocessor '''
    parser = argparse.ArgumentParser(
        description="Simulate a receiver with built-in preprocessor.")

    parser.add_argument("mapfile", nargs=1, type=argparse.FileType('r'),
        help="the filename of the map file to summarize")

    return parser.parse_args()


def main():
    ''' Program start '''
    try:
        args = parse_commandline()
        map_file_parser(args)
    except KeyboardInterrupt:
        print("")
        sys.exit(0)


if __name__ == '__main__':
    main()
