#!/usr/bin/env python
'''
parse_gcc_map_file.py

Provides a summary for FLASH and RAM usage, based on the .map file
generated by the linker.

This file is specific for the map format generated by GCC.
Hint: to generate the map file add the -Map=MAPFILENAME to the linker flags

Author:         Werner Lane
E-mail:         laneboysrc@gmail.com
'''

from __future__ import print_function

import sys
import argparse
import re
from collections import defaultdict


def parse_section_dict(dictionary):
    ''' Convert numbers in a section dictionary from strings to integers,
        and set the 'area' to either 'RAM' or 'FLASH' if 'writeable' is 'w'
    '''

    for key in ('start_address', 'size'):
        dictionary[key] = int(dictionary[key], 16)

    if 'writeable' in dictionary:
        if dictionary['writeable'] == 'w':
            dictionary['type'] = "RAM"
        else:
            dictionary['type'] = 'FLASH'
        del dictionary['writeable']

    return dictionary


def parse_memory_sections(map_data):
    ''' Obtain the memory sections (FLASH, RAM ...) '''

    re_flags = re.MULTILINE + re.DOTALL + re.IGNORECASE + re.VERBOSE
    memory_configuration_re = r'''
        .*
        Memory\sConfiguration
        .*
        Attributes
        (.*)
        Linker\sscript\sand\smemory\smap
        .*'''

    entry_re = r'''
        (?P<section_name>\S*)
        \s+
        (?P<start_address>0x\S*)
        \s+
        (?P<size>0x\S*)
        \s+
        xr(?P<writeable>.?)
        '''

    try:
        memory_configuration = re.match(memory_configuration_re, map_data,
            flags=re_flags).group(1)

    except AttributeError:
        print("ERROR: map file does not contain memory configuration")
        sys.exit(1)

    memory_sections = []
    for match in re.finditer(entry_re, memory_configuration, flags=re_flags):
        memory_sections.append(parse_section_dict(match.groupdict()))

    return memory_sections


def parse_memory_map(map_data):
    ''' Obtain the memory map part of the map file '''

    re_flags = re.MULTILINE + re.DOTALL + re.IGNORECASE + re.VERBOSE
    memory_map_re = r'''
        .*
        Linker\sscript\sand\smemory\smap
        (.*)
        (?:Cross\sReference\sTable)?    # May or may not be present
        .*
        '''

    try:
        memory_map = re.match(memory_map_re, map_data, flags=re_flags).group(1)
    except AttributeError:
        print("ERROR: Unable to find memory map in the map file")
        sys.exit(1)

    return memory_map


def get_category(section):
    ''' Categorize module names for the summary this tool outputs '''

    if section['name'] == '*fill*':
        return '(alignment data)'

    if re.match(r'/lib.+\.a$', section['module_name']):
        return '(system libraries)'

    if section['module_name'] == 'crt0.o':
        return '(runtime)'

    if re.match(r'.+\.o$', section['module_name']):
        return section['module_name']

    return '(others)'


def process_sections(memory_map, memory_sections):
    ''' Parse each section that does not have an intializer '''
    re_flags = re.VERBOSE + re.MULTILINE
    section_re = r'''
        ^
        [ ]\.?(?P<name>\S+?)
        \s+
        (?P<start_address>0x\S+)
        [ ]+                        # Match spaces, not \s which matches \n!
        (?P<size>0x\S+)
        [ ]+
        (?P<module_name>.*)
        $
        '''

    sections_to_ignore = ("ARM.attributes", "comment")
    totals = dict(RAM=defaultdict(int), FLASH=defaultdict(int))

    for match in re.finditer(section_re, memory_map, flags=re_flags):
        section = parse_section_dict(match.groupdict())

        if section['size'] == 0:
            continue

        if section['name'] in sections_to_ignore:
            continue

        if section['name'].startswith('debug_'):
            continue


        for memory_section in memory_sections:
            start = memory_section['start_address']
            size = memory_section['size']
            end = start + size
            if start <= section['start_address'] <= end:
                section['memory'] = memory_section['type']
                break

        category = get_category(section)

        totals[section['memory']]['.total'] += section['size']
        totals[section['memory']][category] += section['size']

    return totals


def print_summary(totals):
    ''' Output the summary of memory usage '''
    summary = dict()

    for flash in totals['FLASH']:
        summary[flash] = dict(FLASH=totals['FLASH'][flash], RAM=0)

    for ram in totals['RAM']:
        if ram in summary:
            summary[ram]['RAM'] = totals['RAM'][ram]
        else:
            summary[ram] = dict(RAM=totals['RAM'][ram], FLASH=0)

    print('------------------------------------+-----------+-----------')
    print('Module                              |     FLASH |       RAM')
    print('------------------------------------+-----------+-----------')

    for entry in sorted(summary):
        if entry == '.total':
            continue
        print('{:35} | {:9} | {:9}'.format(
            entry, summary[entry]['FLASH'], summary[entry]['RAM']))

    print('------------------------------------+-----------+-----------')
    print('{:35} | {:9} | {:9}'.format(
            'TOTAL:', summary['.total']['FLASH'], summary['.total']['RAM']
            ))
    print('------------------------------------+-----------+-----------')


def map_file_parser(args):
    ''' Parse the map file and print FLASH and RAM summary information '''
    map_data = args.mapfile[0].read()

    memory_sections = parse_memory_sections(map_data)
    memory_map = parse_memory_map(map_data)
    totals = process_sections(memory_map, memory_sections)
    print_summary(totals)



def parse_commandline():
    ''' Simulate a receiver with built-in preprocessor '''
    parser = argparse.ArgumentParser(
        description="Simulate a receiver with built-in preprocessor.")

    parser.add_argument("mapfile", nargs=1, type=argparse.FileType('r'),
        help="the filename of the map file to summarize")

    return parser.parse_args()


def main():
    ''' Program start '''
    try:
        args = parse_commandline()
        map_file_parser(args)
    except KeyboardInterrupt:
        print("")
        sys.exit(0)


if __name__ == '__main__':
    main()
